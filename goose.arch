/* 
	GOOSE ARCHITECTURE v1.0
			  __
			>(' )
			  )/   .`
			 /(____/\
			/        )
			\ `  =~~/
			 `-----|
		  - - -  ~~^  - -

	Word length: 		16 bits
	Class:				Stack virtual machine
	Memory regions: 	Code, constants, data, stack
*/

architecture Goose {
	/* 
		NAMING SYSTEM:

		Private internal names:
			mName 		- memory range
			efName	 	- encoded field
			esName		- encoded sequence

		Public names:
			Registsers should be written in CAPS.
			Mnemonics are written in lower case.
	*/

	registers:
		storage STACK_STORAGE[32];									/* A little-endian physical storage to serve for stack maintaining purposes: */
																	/* [0 .. SSZ .. 15 ][ 16 .. CSZ .. 31] */

		storage SYSTEM_STORAGE[16];									/* A little-endian physical storage for system essential data: */
																	/* [0 .. ERR .. 15] */


		view SSZ = STACK_STORAGE[0..15];							/* A view for the current Stack Size storage */

		view CSZ = STACK_STORAGE[16..31];							/* A view for the subroutine Caller's stack Size storage at the entry point */
																	/* For "main" or "root" subroutine it's -1 */

		view ERR = SYSTEM_STORAGE[0..15];							/* A view for the current error code storage */

		/*
			ERROR CODES:
				0 - No error

		*/
		
	memory:
		range mCode[0x0000..0xFFFF] {
			cell = 8;
			endianess = little-endian;
			granularity = 0;
		}

		range mConsts[0x0000..0xFFFF] {
			cell = 8;
			endianess = little-endian;
			granularity = 0;
		}

		range mData[0x0000..0xFFFF] {
			cell = 8;
			endianess = little-endian;
			granularity = 0;
		}

		/* 
			Each element has size of 2 bytes, so a pointer to the back element can be calculated like [__m_stack + (cell=16) * SSZ] 
		*/
		range mStack[0x0000..0xFFFF] {
			cell = 8;
			endianess = little-endian;
			granularity = 0;
		}

	instructions:
		/* ---------------- TYPE ENCODINGS ---------------- */

		encode imm8		field = immediate[8] data;						/* generic data stored in 1 byte */
		encode imm16	field = immediate[16] data;						/* generic data stored in 2 bytes */
		encode imm32	field = immediate[32] data;						/* generic data stored in 4 bytes */
		encode imm64	field = immediate[64] data;						/* generic data stored in 8 bytes */

		encode ofs16  	field = immediate[16] offset;					/* memory offset (maximum is 0xFFFF, what is the size of any memory range) */

		encode reg 		field = register {								/* BITS OF REGISERS DEFINITION */
			SSZ = 00,
			CSZ = 01,
			ERR = 10
		};

		encode instrType field = cases { 								/* BITS OF INSTRUCTION TYPES DEFINITION */
			stack 		= 000,											/* 000x xxxx are stack instructions except nop = { 0000 0000 } */
			flowctrl 	= 001,										
			arithmetic	= 010,
			bitwise		= 011,
			io 			= 100,
			other 		= 101
		};


		/* -------------- STACK INSTRUCTIONS -------------- */

		// instruction nop 			= { 0000 0000 }; - declared in OTHER INSTRUCTIONS

		instruction pop 			= { instrType.stack, 00001, ofs16 as destofs };
		instruction push_ofs 		= { instrType.stack, 00010, ofs16 as ofs };
		instruction push_by_ofs	 	= { instrType.stack, 00011, ofs16 as srcofs };
		instruction push_b		 	= { instrType.stack, 00100, imm8 as imm };
		instruction push_w		 	= { instrType.stack, 00101, imm16 as imm };
		instruction push_d	 		= { instrType.stack, 00110, imm32 as imm };
		instruction push_q	 		= { instrType.stack, 00111, imm64 as imm };
		instruction swp			 	= { instrType.stack, 01000 };
		instruction sav			 	= { instrType.stack, 01001, ofs16 as destofs };

		
		/* ----------- FLOW CONTROL INSTRUCTIONS ---------- */

		instruction jmp 			= { instrType.flowctrl, 00000, ofs16 as label };
		
		/* ------------ ARITHMETIC INSTRUCTIONS ----------- */

		// instruction add = {};


		/* ------------- BITWISE INSTRUCTIONS ------------- */


		/* ----------- INPUT/OUTPUT INSTRUCTIONS ---------- */
		

		/* -------------- OTHER INSTRUCTIONS -------------- */

		instruction nop = { 0000 0000 };

	
	mnemonics:

		/* --------- ARGUMENT FORMAT DEFINITIONS ---------- */

		format arg_plain 		is "{1}";
		format arg_offset 		is "&{1}";
		format arg_imm_byte 	is "b {1}";
		format arg_imm_word 	is "w {1}";
		format arg_imm_double 	is "d {1}";
		format arg_imm_quad 	is "q {1}";


		/* ------------ FOR STACK INSTRUCTIONS ------------- */

		mnemonic pop 	(destofs) arg_plain when ofs16;
		mnemonic push 	for push_ofs (ofs) arg_offset,
						for push_by_ofs (srcofs) arg_plain when ofs16,
						for push_b (imm) arg_imm_byte when imm8,
						for push_w (imm) arg_imm_word when imm16,
						for push_d (imm) arg_imm_double when imm32,
						for push_q (imm) arg_imm_quad when imm64;
		mnemonic swp();
		mnemonic sav	(destofs) arg_plain when ofs16;

		/* --------- FOR FLOW CONTROL INSTRUCTIONS --------- */

		// jmp
		// jump by offset?
		
		// je
		// jl
		// jg
		// jle
		// jge

		// jez
		// jgz
		// jlz
		// jgez
		// jlez

		// call symb
		// ret
		// calln symb // call with n args put onto subroutine's stack
		// retn		  // return with n top vals put onto caller's stack
		
		/* ---------- FOR ARITHMETIC INSTRUCTIONS ---------- */

		//mnemonic add() for add_0;
		
		// sub
		// inc
		// dec
		// mlt
		// neg
		// div
		// mod
		
		/* ----------- FOR BITWISE INSTRUCTIONS ----------- */
		// not
		// and
		// or
		// xor


		/* --------- FOR INPUT/OUTPUT INSTRUCTIONS -------- */
		
		// nbinp 		// number of byte input
		// nwinp		// number of word input
		// ndinp		// number of double word input
		// nqinp		// number of quadword input
		// cbinp		// input character as a byte

		//out



		/* ----------- FOR OTHER INSTRUCTIONS ------------- */

		mnemonic nop();

		// cmp -> -1 0 1
		// stop


}