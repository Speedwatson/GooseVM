/* 
	GOOSE ARCHITECTURE v1.0
			  __
			>(' )
			  )/    ~
			 /(____/\
			/        )
			\ `  =~~/
			 `-----|
		  - - -  ~~^  - -

	Word length: 		16 bits
	Class:				Stack virtual machine
	Memory regions: 	Code, constants, data, stack
*/

architecture Goose {
	/* 
		NAMING SYSTEM:

		Private internal names:
			mName 		- memory range
			efName	 	- encoded field
			esName		- encoded sequence

		Public names:
			Registsers should be written in CAPS.
			Mnemonics are written in lower case.
	*/

	registers:
		storage STACK_STORAGE[32];									/* A little-endian physical storage to serve for stack maintaining purposes: */
																	/* [0 .. SSZ .. 15 ][ 16 .. CSZ .. 31] */

//		storage SYSTEM_STORAGE[16];									/* A little-endian physical storage for system essential data: */
																	/* [0 .. ERR .. 15] */

		view SSZ = STACK_STORAGE[0..15];							/* A view for the current Stack Size storage */

		view CSZ = STACK_STORAGE[16..31];							/* A view for the subroutine Caller's stack Size storage at the entry point */
																	/* For "main" or "root" subroutine it's -1 */

//		view ERR = SYSTEM_STORAGE[0..15];							/* A view for the current error code storage */
//
//		/*
//			ERROR CODES:
//				0 - No error
//				
//		*/
		
	memory:
		range mCode[0x0000..0xFFFF] {
			cell = 8;
			endianess = little-endian;
			granularity = 0;
		}

		range mConsts[0x0000..0xFFFF] {
			cell = 8;
			endianess = little-endian;
			granularity = 0;
		}

		range mData[0x0000..0xFFFF] {
			cell = 8;
			endianess = little-endian;
			granularity = 0;
		}

		/* 
			Each element has size of 2 bytes, so a pointer to the back element can be calculated like [__m_stack + (cell=16) * SSZ] 
		*/
		range mStack[0x0000..0xFFFF] {
			cell = 8;
			endianess = little-endian;
			granularity = 0;
		}

	instructions:
		/* ---------------- TYPE ENCODINGS ---------------- */

		encode imm8		field = immediate[8] data;						/* generic data stored in 1 byte */
		encode imm16	field = immediate[16] data;						/* generic data stored in 2 bytes */
		encode imm32	field = immediate[32] data;						/* generic data stored in 4 bytes */
		encode imm64	field = immediate[64] data;						/* generic data stored in 8 bytes */

		encode ofs16  	field = immediate[16] offset;					/* memory offset (maximum is 0xFFFF, what is the size of any memory range) */

		encode reg 		field = register {								/* BITS OF REGISERS DEFINITION */
			SSZ = 00,
			CSZ = 01,
			ERR = 10
		};

		encode instrType field = cases { 								/* BITS OF INSTRUCTION TYPES DEFINITION */
			stack 		= 000,											/* 000x xxxx are stack instructions except nop = { 0000 0000 } */
			flowctrl 	= 001,										
			arithmetic	= 010,
			bitwise		= 011,
			io 			= 100,
			other 		= 101
		};

		encode numOr0AndOfs sequence = alternatives {
			num_not_defined = { 0000 0000, ofs16 as ofs },
			defined = { imm8 as num, ofs16 as ofs }
		};

		encode numOr0 sequence = alternatives {
			defined = { imm8 as num },
			default = { 0000 0000 }
		};

		/* -------------- STACK INSTRUCTIONS -------------- */

		// instruction nop 			= { 0000 0000 }; - declared in OTHER INSTRUCTIONS

		instruction push_ofs 		= { instrType.stack, 0 0010, ofs16 as ofs };
		instruction push_b 		 	= { instrType.stack, 0 0011, imm8 as number };
		instruction push_w 		 	= { instrType.stack, 0 0100, imm16 as number };
		instruction push_d 		 	= { instrType.stack, 0 0101, imm32 as number };
		instruction push_q 		 	= { instrType.stack, 0 0110, imm64 as number };
		instruction push_by_ofs_b	= { instrType.stack, 0 0111, ofs16 as srcofs };
		instruction push_by_ofs_w	= { instrType.stack, 0 1000, ofs16 as srcofs };
		instruction push_by_ofs_d	= { instrType.stack, 0 1001, ofs16 as srcofs };
		instruction push_by_ofs_q	= { instrType.stack, 0 1010, ofs16 as srcofs };
		instruction swp			 	= { instrType.stack, 0 1011 };
		
		instruction pop_b 			= { instrType.stack, 0 1101, ofs16 as destofs };
		instruction pop_w 			= { instrType.stack, 0 1110, ofs16 as destofs };
		instruction pop_d 			= { instrType.stack, 0 1111, ofs16 as destofs };
		instruction pop_q 			= { instrType.stack, 1 0000, ofs16 as destofs };
		instruction sav_b		 	= { instrType.stack, 1 0001, ofs16 as destofs };
		instruction sav_w		 	= { instrType.stack, 1 0010, ofs16 as destofs };
		instruction sav_d		 	= { instrType.stack, 1 0011, ofs16 as destofs };
		instruction sav_q		 	= { instrType.stack, 1 0100, ofs16 as destofs };

		
		/* ----------- FLOW CONTROL INSTRUCTIONS ---------- */

		instruction jmp 			= { instrType.flowctrl, 0 0000, ofs16 as targetLabel };
		instruction jmp_by_offset	= { instrType.flowctrl, 0 0001, ofs16 as targetOfsVarPtr };
 
		instruction je 				= { instrType.flowctrl, 0 0010, ofs16 as targetLabel };
		instruction je_by_offset	= { instrType.flowctrl, 0 0011, ofs16 as targetOfsVarPtr };
		instruction jl 				= { instrType.flowctrl, 0 0100, ofs16 as targetLabel };
		instruction jl_by_offset	= { instrType.flowctrl, 0 0101, ofs16 as targetOfsVarPtr };
		instruction jg 				= { instrType.flowctrl, 0 0110, ofs16 as targetLabel };
		instruction jg_by_offset	= { instrType.flowctrl, 0 0111, ofs16 as targetOfsVarPtr };
		instruction jle 			= { instrType.flowctrl, 0 1000, ofs16 as targetLabel };
		instruction jle_by_offset	= { instrType.flowctrl, 0 1001, ofs16 as targetOfsVarPtr };
		instruction jge 			= { instrType.flowctrl, 0 1010, ofs16 as targetLabel };
		instruction jge_by_offset	= { instrType.flowctrl, 0 1011, ofs16 as targetOfsVarPtr };
 
		instruction jez 			= { instrType.flowctrl, 0 1100, ofs16 as targetLabel };
		instruction jez_by_offset	= { instrType.flowctrl, 0 1101, ofs16 as targetOfsVarPtr };
		instruction jgz 			= { instrType.flowctrl, 0 1110, ofs16 as targetLabel };
		instruction jgz_by_offset	= { instrType.flowctrl, 0 1111, ofs16 as targetOfsVarPtr };
		instruction jlz 			= { instrType.flowctrl, 1 0000, ofs16 as targetLabel };
		instruction jlz_by_offset	= { instrType.flowctrl, 1 0001, ofs16 as targetOfsVarPtr };
		instruction jgez 			= { instrType.flowctrl, 1 0010, ofs16 as targetLabel };
		instruction jgez_by_offset	= { instrType.flowctrl, 1 0011, ofs16 as targetOfsVarPtr };
		instruction jlez 			= { instrType.flowctrl, 1 0100, ofs16 as targetLabel };
		instruction jlez_by_offset	= { instrType.flowctrl, 1 0101, ofs16 as targetOfsVarPtr };

		instruction call 			= { instrType.flowctrl, 1 0110, sequence numOr0AndOfs }; // numOr0AndOfs(num as argsNumber, ofs as subroutineLabel) };
//	    instruction call_nargs		= { instrType.flowctrl, 1 0111, ofs16 as subroutineLabel, imm8 as argsNumber };
		
		instruction ret 			= { instrType.flowctrl, 1 1000, sequence numOr0 };
//		instruction ret_nvalues		= { instrType.flowctrl, 1 1001, imm8 as valuesNumber };


		/* ------------ ARITHMETIC INSTRUCTIONS ----------- */

		instruction add 			= { instrType.arithmetic, 0 0000 };
		instruction sub 			= { instrType.arithmetic, 0 0001 };
		instruction inc 			= { instrType.arithmetic, 0 0010 };
		instruction dec 			= { instrType.arithmetic, 0 0011 };
		instruction mlt 			= { instrType.arithmetic, 0 0100 };
		instruction div 			= { instrType.arithmetic, 0 0101 };
		instruction mod 			= { instrType.arithmetic, 0 0110 };


		/* ------------- BITWISE INSTRUCTIONS ------------- */

		instruction bnot 			= { instrType.bitwise, 0 0000 };
		instruction band	 			= { instrType.bitwise, 0 0001 };
		instruction bor	 			= { instrType.bitwise, 0 0010 };
		instruction bxor	 			= { instrType.bitwise, 0 0011 };


		/* ----------- INPUT/OUTPUT INSTRUCTIONS ---------- */
		
		instruction inp_b			= { instrType.io, 0 0000, ofs16 as dest };
		instruction inp_b_stack		= { instrType.io, 0 0001 };
		instruction inp_w			= { instrType.io, 0 0010, ofs16 as dest };
		instruction inp_w_stack		= { instrType.io, 0 0011 };
		instruction inp_d			= { instrType.io, 0 0100, ofs16 as dest };
		instruction inp_d_stack		= { instrType.io, 0 0101 };
		instruction inp_q			= { instrType.io, 0 0110, ofs16 as dest };
		instruction inp_q_stack		= { instrType.io, 0 0111 };
		instruction inp_char		= { instrType.io, 0 1000, ofs16 as dest };
		instruction inp_char_stack	= { instrType.io, 0 1001 };

		instruction out_b			= { instrType.io, 0 1010, ofs16 as src };
		instruction out_b_stack		= { instrType.io, 0 1011 };
		instruction out_w			= { instrType.io, 0 1100, ofs16 as src };
		instruction out_w_stack		= { instrType.io, 0 1101 };
		instruction out_d			= { instrType.io, 0 1110, ofs16 as src };
		instruction out_d_stack		= { instrType.io, 0 1111 };
		instruction out_q			= { instrType.io, 1 0000, ofs16 as src };
		instruction out_q_stack		= { instrType.io, 1 0001 };
		instruction out_char		= { instrType.io, 1 0010, ofs16 as src };
		instruction out_char_stack	= { instrType.io, 1 0011 };


		/* -------------- OTHER INSTRUCTIONS -------------- */

		instruction nop 			= { 0000 0000 };
		instruction stop 			= { instrType.other, 0 0000, sequence numOr0 };
		instruction stop_ecstack 	= { instrType.other, 0 0001 };


	
	mnemonics:

		/* --------- ARGUMENT FORMAT DEFINITIONS ---------- */

		format arg_plain 		is "{1}";
		format arg_dereference	is "*{1}";

		format arg_plain_plain  is "{1} {2}";


		/* ------------ FOR STACK INSTRUCTIONS ------------- */

		mnemonic push 	for push_ofs (ofs) arg_plain,
						for push_b (number) "b {1}",
						for push_w (number) "w {1}",
						for push_d (number) "d {1}",
						for push_q (number) "q {1}",
						for push_by_ofs_b (srcofs) "*{1}",
						for push_by_ofs_w (srcofs) "w *{1}",
						for push_by_ofs_d (srcofs) "d *{1}",
						for push_by_ofs_q (srcofs) "q *{1}";
						
		mnemonic swp();

		mnemonic pop 	for pop_b (destofs) "{1} b",
						for pop_w (destofs) "{1} w",
						for pop_d (destofs) "{1} d",
						for pop_q (destofs) "{1} q";

		mnemonic sav 	for sav_b (destofs) "{1} b",
						for sav_w (destofs) "{1} w",
						for sav_d (destofs) "{1} d",
						for sav_q (destofs) "{1} q";	


		/* --------- FOR FLOW CONTROL INSTRUCTIONS --------- */

		mnemonic jmp 	(targetLabel) arg_plain,
						for jmp_by_offset (targetOfsVarPtr) arg_dereference;

		mnemonic je 	(targetLabel) arg_plain,
						for je_by_offset (targetOfsVarPtr) arg_dereference;
		mnemonic jl 	(targetLabel) arg_plain,
						for jl_by_offset (targetOfsVarPtr) arg_dereference;
		mnemonic jg 	(targetLabel) arg_plain,
						for jg_by_offset (targetOfsVarPtr) arg_dereference;
		mnemonic jle 	(targetLabel) arg_plain,
						for jle_by_offset (targetOfsVarPtr) arg_dereference;
		mnemonic jge 	(targetLabel) arg_plain,
						for jge_by_offset (targetOfsVarPtr) arg_dereference;

		mnemonic jez 	(targetLabel) arg_plain,
						for jez_by_offset (targetOfsVarPtr) arg_dereference;
		mnemonic jgz 	(targetLabel) arg_plain,
						for jgz_by_offset (targetOfsVarPtr) arg_dereference;
		mnemonic jlz 	(targetLabel) arg_plain,
						for jlz_by_offset (targetOfsVarPtr) arg_dereference;
		mnemonic jgez 	(targetLabel) arg_plain,
						for jgez_by_offset (targetOfsVarPtr) arg_dereference;
		mnemonic jlez 	(targetLabel) arg_plain,
						for jlez_by_offset (targetOfsVarPtr) arg_dereference;

		mnemonic call 	(ofs) arg_plain when num_not_defined,
						(ofs, num) arg_plain_plain when defined; // call with n args put onto subroutine's stack

		mnemonic ret 	() when default,
						(num) arg_plain when defined; // return with n top vals put onto caller's stack ("returned")


		/* ---------- FOR ARITHMETIC INSTRUCTIONS ---------- */

		mnemonic add();
		mnemonic sub();
		mnemonic inc();
		mnemonic dec();
		mnemonic mlt();
		mnemonic div();
		mnemonic mod();


		/* ----------- FOR BITWISE INSTRUCTIONS ----------- */

		mnemonic bnot();
		mnemonic band();
		mnemonic bor();
		mnemonic bxor();


		/* --------- FOR INPUT/OUTPUT INSTRUCTIONS -------- */

		mnemonic inp 	for inp_b (dest) "b {1}",
					 	for inp_b_stack () "b",
					 	for inp_w (dest) "w {1}",
					 	for inp_w_stack () "w",
					 	for inp_d (dest) "d {1}",
					 	for inp_d_stack () "d",
					 	for inp_q (dest) "q {1}",
					 	for inp_q_stack () "q",
					 	for inp_char (dest) "c {1}",
					 	for inp_char_stack () "c";
	
		mnemonic out 	for out_b (src) "b {1}",
					 	for out_b_stack () "b",
					 	for out_w (src) "w {1}",
					 	for out_w_stack () "w",
					 	for out_d (src) "d {1}",
					 	for out_d_stack () "d",
					 	for out_q (src) "q {1}",
					 	for out_q_stack () "q",
					 	for out_char (src) "c {1}",
					 	for out_char_stack () "c";
					 	


		/* ----------- FOR OTHER INSTRUCTIONS ------------- */

		mnemonic nop();
		mnemonic stop 	(num) arg_plain when defined,
						() when default,
						for stop_ecstack () "pop";


		// cpy: copy value from constants to data

		// cmp -> -1 0 1
}
