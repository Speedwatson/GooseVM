/* 
	GOOSE ARCHITECTURE v1.0
			  __
			>(' )
			  )/   .`
			 /(____/\
			/        )
			\ `  =~~/
			 `-----|
		  - - -  ~~^  - -

	Word length: 		16 bits
	Class:				Stack virtual machine
	Memory regions: 	Code, constants, data, stack
*/

architecture Goose {
	/* 
		NAMING SYSTEM:

		Private internal names:
			mName 		- memory range
			efName	 	- encoded field
			esName		- encoded sequence

		Public names:
			Registsers should be written in CAPS.
			Mnemonics are written in lower case.
	*/

	registers:
		storage STACK_STORAGE[32];									/* A little-endian physical storage to serve for stack maintaining purposes: */
																	/* [0 .. SSZ .. 15 ][ 16 .. CSZ .. 31] */

		storage SYSTEM_STORAGE[16];									/* A little-endian physical storage for system essential data: */
																	/* [0 .. ERR .. 15] */


		view SSZ = STACK_STORAGE[0..15];							/* A view for the current Stack Size storage */

		view CSZ = STACK_STORAGE[16..31];							/* A view for the subroutine Caller's stack Size storage at the entry point */
																	/* For "main" or "root" subroutine it's -1 */

		view ERR = A[16..31];										/* A view for the current error code storage */

		/*
			ERROR CODES:
				0 - No error

		*/
		
	memory:
		range mCode[0x0000..0xFFFF] {
			cell = 8;
			endianess = little-endian;
			granularity = 0;
		}

		range mConsts[0x0000..0xFFFF] {
			cell = 8;
			endianess = little-endian;
			granularity = 0;
		}

		range mData[0x0000..0xFFFF] {
			cell = 8;
			endianess = little-endian;
			granularity = 0;
		}

		/* 
			Each element has size of 2 bytes, so a pointer to the back element can be calculated like [__m_stack + (cell=16) * SSZ] 
		*/
		range mStack[0x0000..0xFFFF] {
			cell = 8;
			endianess = little-endian;
			granularity = 0;
		}

	instructions:
		/* ---------------- TYPE ENCODINGS ---------------- */

		encode efImm8	field = immediate[8] data;						/* generic data stored in 1 byte */
		encode efImm16	field = immediate[16] data;						/* generic data stored in 2 bytes */
		encode efImm32	field = immediate[32] data;						/* generic data stored in 4 bytes */
		encode efImm64	field = immediate[64] data;						/* generic data stored in 8 bytes */

		encode efOff 	field = immediate[16] offset;					/* memory offset (maximum is 0xFFFF, what is the size of any memory range) */

		encode efReg	field = register {								/* BITS OF REGISERS DEFINITION */
			SSZ = 00,													/* We'll leave some space for possible regiesters introduced in future */
			ERR = 10
		};

		encode efInstrType	field = cases { 							/* BITS OF INSTRUCTION TYPES DEFINITION */
			stack 		= 000,											/* 000x xxxx are stack instructions except nop{ 0000 0000 } */
			flowctrl 	= 001,
			arithmetic	= 010,
			bitwise		= 011,
			io 			= 100,
			other 		= 101
		};


		/* -------------- STACK INSTRUCTIONS -------------- */

		
		/* ----------- FLOW CONTROL INSTRUCTIONS ---------- */

		
		/* ------------ ARITHMETIC INSTRUCTIONS ----------- */

		instruction add = {};


		/* ------------- BITWISE INSTRUCTIONS ------------- */


		/* ----------- INPUT/OUTPUT INSTRUCTIONS ---------- */
		

		/* -------------- OTHER INSTRUCTIONS -------------- */

		instruction nop = { 0000 0000 };

	
	mnemonics:

		/* ------------ FOR STACK INSTRUCTIONS ------------- */

		// pop dest
		// push imm/dest
		// swp
		// sav
		
		/* --------- FOR FLOW CONTROL INSTRUCTIONS --------- */

		// jmp
		// jump by offset?
		
		// je
		// jl
		// jg
		// jle
		// jge

		// jez
		// jgz
		// jlz
		// jgez
		// jlez

		// call symb
		// ret
		// calln symb // call with n args put onto subroutine's stack
		// retn		  // return with n top vals put onto caller's stack
		
		/* ---------- FOR ARITHMETIC INSTRUCTIONS ---------- */

		mnemonic add() for add_0;
		
		// sub
		// inc
		// dec
		// mlt
		// neg
		// div
		// mod
		
		/* ----------- FOR BITWISE INSTRUCTIONS ----------- */
		// not
		// and
		// or
		// xor


		/* --------- FOR INPUT/OUTPUT INSTRUCTIONS -------- */
		
		// nbinp 		// number of byte input
		// nwinp		// number of word input
		// ndinp		// number of double word input
		// nqinp		// number of quadword input
		// cbinp		// input character as a byte

		//out



		/* ----------- FOR OTHER INSTRUCTIONS ------------- */

		mnemonic nop();

		// cmp -> -1 0 1
		// stop


}