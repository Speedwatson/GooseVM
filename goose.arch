/* 
	GOOSE ARCHITECTURE v1.0
			  __
			>(' )
			  )/   .`
			 /(____/\
			/        )
			\ `  =~~/
			 `-----|
		  - - -  ~~^  - -

	Word length: 		16 bits
	Class:				Stack virtual machine
	Memory regions: 	Code, constants, data, stack
*/

architecture Goose {
	/* 
		NAMING SYSTEM:

		Private internal names:
			mName 		- memory range
			efName	 	- encoded field
			esName		- encoded sequence

		Public names:
			Registsers should be written in CAPS.
			Mnemonics are written in lower case.
	*/

	registers:
		storage STACK_STORAGE[32];									/* A little-endian physical storage to serve for stack maintaining purposes: */
																	/* [0 .. SSZ .. 15 ][ 16 .. CSZ .. 31] */

		storage SYSTEM_STORAGE[16];									/* A little-endian physical storage for system essential data: */
																	/* [0 .. ERR .. 15] */


		view SSZ = STACK_STORAGE[0..15];							/* A view for the current Stack Size storage */

		view CSZ = STACK_STORAGE[16..31];							/* A view for the subroutine Caller's stack Size storage at the entry point */
																	/* For "main" or "root" subroutine it's -1 */

		view ERR = SYSTEM_STORAGE[0..15];							/* A view for the current error code storage */

		/*
			ERROR CODES:
				0 - No error

		*/
		
	memory:
		range mCode[0x0000..0xFFFF] {
			cell = 8;
			endianess = little-endian;
			granularity = 0;
		}

		range mConsts[0x0000..0xFFFF] {
			cell = 8;
			endianess = little-endian;
			granularity = 0;
		}

		range mData[0x0000..0xFFFF] {
			cell = 8;
			endianess = little-endian;
			granularity = 0;
		}

		/* 
			Each element has size of 2 bytes, so a pointer to the back element can be calculated like [__m_stack + (cell=16) * SSZ] 
		*/
		range mStack[0x0000..0xFFFF] {
			cell = 8;
			endianess = little-endian;
			granularity = 0;
		}

	instructions:
		/* ---------------- TYPE ENCODINGS ---------------- */

		encode imm8		field = immediate[8] data;						/* generic data stored in 1 byte */
		encode imm16	field = immediate[16] data;						/* generic data stored in 2 bytes */
		encode imm32	field = immediate[32] data;						/* generic data stored in 4 bytes */
		encode imm64	field = immediate[64] data;						/* generic data stored in 8 bytes */

		encode ofs16  	field = immediate[16] offset;					/* memory offset (maximum is 0xFFFF, what is the size of any memory range) */

		encode reg 		field = register {								/* BITS OF REGISERS DEFINITION */
			SSZ = 00,
			CSZ = 01,
			ERR = 10
		};

		encode instrType field = cases { 								/* BITS OF INSTRUCTION TYPES DEFINITION */
			stack 		= 000,											/* 000x xxxx are stack instructions except nop = { 0000 0000 } */
			flowctrl 	= 001,										
			arithmetic	= 010,
			bitwise		= 011,
			io 			= 100,
			other 		= 101
		};

		encode ofsAndNum sequence = alternatives {
			num_is_one = { 0000 0001, ofs16 as ofs },
			defined = { imm8 as num, ofs16 as ofs }
		};

		encode numOr0 sequence = alternatives {
			defined = { imm8 as num },
			default = { 0000 0000 }
		};


		/* -------------- STACK INSTRUCTIONS -------------- */

		// instruction nop 			= { 0000 0000 }; - declared in OTHER INSTRUCTIONS

		instruction pop 			= { instrType.stack, 0 0001, ofs16 as destofs };
		instruction push_ofs 		= { instrType.stack, 0 0010, ofs16 as ofs };
		instruction push_by_ofs	 	= { instrType.stack, 0 0011, ofs16 as srcofs };
		instruction push_b		 	= { instrType.stack, 0 0100, imm8 as imm };
		instruction push_w		 	= { instrType.stack, 0 0101, imm16 as imm };
		instruction push_d	 		= { instrType.stack, 0 0110, imm32 as imm };
		instruction push_q	 		= { instrType.stack, 0 0111, imm64 as imm };
		instruction swp			 	= { instrType.stack, 0 1000 };
		instruction sav			 	= { instrType.stack, 0 1001, ofs16 as destofs };

		
		/* ----------- FLOW CONTROL INSTRUCTIONS ---------- */

		instruction jmp 			= { instrType.flowctrl, 0 0000, ofs16 as targetLabel };
		instruction jmp_by_offset	= { instrType.flowctrl, 0 0001, ofs16 as targetOfsVarPtr };
 
		instruction je 				= { instrType.flowctrl, 0 0010, ofs16 as targetLabel };
		instruction je_by_offset	= { instrType.flowctrl, 0 0011, ofs16 as targetOfsVarPtr };
		instruction jl 				= { instrType.flowctrl, 0 0100, ofs16 as targetLabel };
		instruction jl_by_offset	= { instrType.flowctrl, 0 0101, ofs16 as targetOfsVarPtr };
		instruction jg 				= { instrType.flowctrl, 0 0110, ofs16 as targetLabel };
		instruction jg_by_offset	= { instrType.flowctrl, 0 0111, ofs16 as targetOfsVarPtr };
		instruction jle 			= { instrType.flowctrl, 0 1000, ofs16 as targetLabel };
		instruction jle_by_offset	= { instrType.flowctrl, 0 1001, ofs16 as targetOfsVarPtr };
		instruction jge 			= { instrType.flowctrl, 0 1010, ofs16 as targetLabel };
		instruction jge_by_offset	= { instrType.flowctrl, 0 1011, ofs16 as targetOfsVarPtr };
 
		instruction jez 			= { instrType.flowctrl, 0 1100, ofs16 as targetLabel };
		instruction jez_by_offset	= { instrType.flowctrl, 0 1101, ofs16 as targetOfsVarPtr };
		instruction jgz 			= { instrType.flowctrl, 0 1110, ofs16 as targetLabel };
		instruction jgz_by_offset	= { instrType.flowctrl, 0 1111, ofs16 as targetOfsVarPtr };
		instruction jlz 			= { instrType.flowctrl, 1 0000, ofs16 as targetLabel };
		instruction jlz_by_offset	= { instrType.flowctrl, 1 0001, ofs16 as targetOfsVarPtr };
		instruction jgez 			= { instrType.flowctrl, 1 0010, ofs16 as targetLabel };
		instruction jgez_by_offset	= { instrType.flowctrl, 1 0011, ofs16 as targetOfsVarPtr };
		instruction jlez 			= { instrType.flowctrl, 1 0100, ofs16 as targetLabel };
		instruction jlez_by_offset	= { instrType.flowctrl, 1 0101, ofs16 as targetOfsVarPtr };

		instruction call 			= { instrType.flowctrl, 1 0110, sequence ofsAndNum }; // ofsAndNum(num as argsNumber, ofs as subroutineLabel) };
//	    instruction call_nargs		= { instrType.flowctrl, 1 0111, ofs16 as subroutineLabel, imm8 as argsNumber };
		
		instruction ret 			= { instrType.flowctrl, 1 1000 };
		instruction ret_nvalues		= { instrType.flowctrl, 1 1001, imm8 as valuesNumber };


		/* ------------ ARITHMETIC INSTRUCTIONS ----------- */

		instruction add 			= { instrType.arithmetic, 0 0000 };
		instruction sub 			= { instrType.arithmetic, 0 0001 };
		instruction inc 			= { instrType.arithmetic, 0 0010 };
		instruction dec 			= { instrType.arithmetic, 0 0011 };
		instruction mlt 			= { instrType.arithmetic, 0 0100 };
		instruction div 			= { instrType.arithmetic, 0 0101 };
		instruction mod 			= { instrType.arithmetic, 0 0110 };


		/* ------------- BITWISE INSTRUCTIONS ------------- */

		instruction bnot 			= { instrType.bitwise, 0 0000 };
		instruction band	 			= { instrType.bitwise, 0 0001 };
		instruction bor	 			= { instrType.bitwise, 0 0010 };
		instruction bxor	 			= { instrType.bitwise, 0 0011 };


		/* ----------- INPUT/OUTPUT INSTRUCTIONS ---------- */
		
		instruction inp_b			= { instrType.io, 0 0000, sequence ofsAndNum }; //imm8 as number, ofs16 as dest };
		instruction inp_w			= { instrType.io, 0 0001, sequence ofsAndNum }; //imm8 as number, ofs16 as dest };
		instruction inp_d			= { instrType.io, 0 0010, sequence ofsAndNum }; //imm8 as number, ofs16 as dest };
		instruction inp_q			= { instrType.io, 0 0011, sequence ofsAndNum }; //imm8 as number, ofs16 as dest };
		instruction inp_char		= { instrType.io, 0 0100, sequence ofsAndNum }; //imm8 as number, ofs16 as dest };
		instruction out_b			= { instrType.io, 0 0101, sequence ofsAndNum }; //imm8 as number, ofs16 as src };
		instruction out_w			= { instrType.io, 0 0110, sequence ofsAndNum }; //imm8 as number, ofs16 as src };
		instruction out_d			= { instrType.io, 0 0111, sequence ofsAndNum }; //imm8 as number, ofs16 as src };
		instruction out_q			= { instrType.io, 0 1000, sequence ofsAndNum }; //imm8 as number, ofs16 as src };
		instruction out_char		= { instrType.io, 0 1001, sequence ofsAndNum }; //imm8 as number, ofs16 as src };


		/* -------------- OTHER INSTRUCTIONS -------------- */

		instruction nop 			= { 0000 0000 };
		instruction stop 			= { instrType.other, 0 0000, sequence numOr0 };


	
	mnemonics:

		/* --------- ARGUMENT FORMAT DEFINITIONS ---------- */

		format arg_plain 		is "{1}";
		format arg_offset 		is "&{1}";
		format arg_dereference	is "*{1}";
		format arg_imm_byte 	is "b {1}";
		format arg_imm_word 	is "w {1}";
		format arg_imm_double 	is "d {1}";
		format arg_imm_quad 	is "q {1}";

		format arg_plain_plain  is "{1} {2}";


		/* ------------ FOR STACK INSTRUCTIONS ------------- */

		mnemonic pop 	(destofs) arg_plain when ofs16;
		mnemonic push 	for push_ofs (ofs) arg_offset,
						for push_by_ofs (srcofs) arg_plain when ofs16,
						for push_b (imm) arg_imm_byte when imm8,
						for push_w (imm) arg_imm_word when imm16,
						for push_d (imm) arg_imm_double when imm32,
						for push_q (imm) arg_imm_quad when imm64;
		mnemonic swp();
		mnemonic sav	(destofs) arg_plain when ofs16;

		/* --------- FOR FLOW CONTROL INSTRUCTIONS --------- */

		mnemonic jmp 	(targetLabel) arg_plain when ofs16,
						for jmp_by_offset (targetOfsVarPtr) arg_dereference when ofs16;

		mnemonic je 	(targetLabel) arg_plain when ofs16,
						for je_by_offset (targetOfsVarPtr) arg_dereference when ofs16;
		mnemonic jl 	(targetLabel) arg_plain when ofs16,
						for jl_by_offset (targetOfsVarPtr) arg_dereference when ofs16;
		mnemonic jg 	(targetLabel) arg_plain when ofs16,
						for jg_by_offset (targetOfsVarPtr) arg_dereference when ofs16;
		mnemonic jle 	(targetLabel) arg_plain when ofs16,
						for jle_by_offset (targetOfsVarPtr) arg_dereference when ofs16;
		mnemonic jge 	(targetLabel) arg_plain when ofs16,
						for jge_by_offset (targetOfsVarPtr) arg_dereference when ofs16;

		mnemonic jez 	(targetLabel) arg_plain when ofs16,
						for jez_by_offset (targetOfsVarPtr) arg_dereference when ofs16;
		mnemonic jgz 	(targetLabel) arg_plain when ofs16,
						for jgz_by_offset (targetOfsVarPtr) arg_dereference when ofs16;
		mnemonic jlz 	(targetLabel) arg_plain when ofs16,
						for jlz_by_offset (targetOfsVarPtr) arg_dereference when ofs16;
		mnemonic jgez 	(targetLabel) arg_plain when ofs16,
						for jgez_by_offset (targetOfsVarPtr) arg_dereference when ofs16;
		mnemonic jlez 	(targetLabel) arg_plain when ofs16,
						for jlez_by_offset (targetOfsVarPtr) arg_dereference when ofs16;

		mnemonic call 	(ofs) arg_plain when num_is_one,
						(ofs, num) arg_plain_plain when defined; // call with n args put onto subroutine's stack

		mnemonic ret 	(),
						for ret_nvalues (valuesNumber) arg_plain; // return with n top vals put onto caller's stack ("returned")


		/* ---------- FOR ARITHMETIC INSTRUCTIONS ---------- */

		mnemonic add();
		mnemonic sub();
		mnemonic inc();
		mnemonic dec();
		mnemonic mlt();
		mnemonic div();
		mnemonic mod();


		/* ----------- FOR BITWISE INSTRUCTIONS ----------- */

		mnemonic bnot();
		mnemonic band();
		mnemonic bor();
		mnemonic bxor();


		/* --------- FOR INPUT/OUTPUT INSTRUCTIONS -------- */

		mnemonic inp 	for inp_b (num, ofs) "{1}b {2}" when defined,
					 	for inp_b (ofs) "b {1}" when num_is_one,
					 	for inp_w (num, ofs) "{1}w {2}" when defined,
					 	for inp_w (ofs) "w {1}" when num_is_one,
					 	for inp_d (num, ofs) "{1}d {2}" when defined,
					 	for inp_d (ofs) "d {1}" when num_is_one,
					 	for inp_q (num, ofs) "{1}q {2}" when defined,
					 	for inp_q (ofs) "q {1}" when num_is_one;
	
		mnemonic out 	for out_b (num, ofs) "{1}b {2}" when defined,
					 	for out_b (ofs) "b {1}" when num_is_one,
					 	for out_w (num, ofs) "{1}w {2}" when defined,
					 	for out_w (ofs) "w {1}" when num_is_one,
					 	for out_d (num, ofs) "{1}d {2}" when defined,
					 	for out_d (ofs) "d {1}" when num_is_one,
					 	for out_q (num, ofs) "{1}q {2}" when defined,
					 	for out_q (ofs) "q {1}" when num_is_one;


		/* ----------- FOR OTHER INSTRUCTIONS ------------- */

		mnemonic nop();
		mnemonic stop 	(num) arg_plain when defined,
						() when default;


		// cmp -> -1 0 1


}